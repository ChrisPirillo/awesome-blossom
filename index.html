<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- === SEO & METADATA === -->
    <!-- Primary Meta Tags -->
    <title>Awesome Blossom - Interactive Generative Art</title>
    <meta name="title" content="Awesome Blossom - Interactive Generative Art">
    <meta name="description" content="Experience 'Awesome Blossom,' a stunning interactive generative art and WebGL shader experiment. Control fractal parameters in real-time.">
    <meta name="keywords" content="generative art, webgl, shader, interactive art, fractal, abstract art, digital art, awesome blossom, web experiment">
    <meta name="author" content="Chris Pirillo">
    <link rel="canonical" href="https://pirillo.com/arcade/awesome-blossom.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/awesome-blossom.html">
    <meta property="og:title" content="Awesome Blossom - Interactive Generative Art">
    <meta property="og:description" content="A stunning interactive generative art and WebGL shader experiment. Control fractal parameters in real-time.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/awesome-blossom.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Pirillo's Arcade">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://pirillo.com/arcade/awesome-blossom.html">
    <meta name="twitter:title" content="Awesome Blossom - Interactive Generative Art">
    <meta name="twitter:description" content="A stunning interactive generative art and WebGL shader experiment. Control fractal parameters in real-time.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/awesome-blossom.png">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">

    <!-- === PERFORMANCE HINTS === -->
    <!-- Preconnect to critical third-party origins -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="preconnect" href="https://www.googletagmanager.com">

    <!-- Load Tailwind CSS (As requested, NOT deferred) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Inlined Critical CSS (Original <style> block - UNCHANGED) -->
    <style>
        /* Basic reset and font */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #111;
        }
        /* Canvas styling */
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        /* Custom scrollbar for the menu */
        #menu::-webkit-scrollbar {
            width: 6px;
        }
        #menu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        #menu::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        #menu::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        /* Style for range input thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #ec4899; /* pink-500 */
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px; /* Center thumb on track */
        }
        input[type=range]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #ec4899;
            border-radius: 50%;
            cursor: pointer;
        }
        /* Style for range input track */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
        }
    </style>

    <!-- === GOOGLE ANALYTICS === -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>
    
    <!-- === STRUCTURED DATA (JSON-LD) === -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Awesome Blossom - Interactive Generative Art",
      "description": "A stunning interactive generative art and WebGL shader experiment. Control fractal parameters in real-time.",
      "url": "https://pirillo.com/arcade/awesome-blossom.html",
      "image": "https://pirillo.com/arcade/images/awesome-blossom.png",
      "creator": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com"
      },
      "isPartOf": {
        "@type": "WebSite",
        "name": "Pirillo's Arcade",
        "url": "https://pirillo.com/arcade/"
      }
    }
    </script>
</head>
<body class="bg-gray-900">

    <!-- Semantic wrapper for main content -->
    <main>
        <!-- WebGL Canvas -->
        <canvas id="glcanvas"></canvas>
    </main>

    <!-- Semantic wrapper for page navigation/controls -->
    <nav>
        <!-- Hamburger Menu Button -->
        <button id="menu-toggle" class="fixed top-4 left-4 z-20 p-3 bg-white/20 backdrop-blur-md rounded-lg text-white shadow-lg transition-transform hover:scale-105 active:scale-95">
            <!-- Explicit width/height added for CLS prevention, though it was already present -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>

        <!-- Slide-out Menu -->
        <div id="menu" class="fixed top-0 left-0 h-full w-80 max-w-[90vw] bg-gray-900/80 backdrop-blur-lg text-white p-6 z-10 shadow-2xl
                            transform -translate-x-full transition-transform duration-300 ease-in-out 
                            overflow-y-auto pt-16">
            <h2 class="text-2xl font-bold mb-6 text-pink-400">Shader Controls</h2>
            
            <!-- Sliders will be dynamically generated here -->
            <div id="slider-container"></div>
        </div>
    </nav>

    <!-- Vertex Shader (Data block - UNCHANGED) -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader (Data block - UNCHANGED) -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 iResolution;
        uniform float iTime;

        // Configurable Uniforms
        // MODIFIED: Removed zoom, cam_x, and cam_y
        uniform float u_max_steps;
        uniform float u_ambient;
        uniform float u_hue_offset;
        uniform float u_saturation;
        uniform float u_brightness;
        uniform float u_step_scale;
        uniform float u_ray_step_size;
        uniform float u_time_scale;
        uniform float u_de_param1;
        uniform float u_de_param2;
        uniform float u_de_param3;
        uniform float u_fractal_limit;
        uniform float u_fractal_param;

        // HSV to RGB conversion function
        vec3 hsv(float h, float s, float v) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);
            return v * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), s);
        }

        void main() {
            // MODIFIED: Use an accumulator variable 'o' just like the original shader
            vec3 o = vec3(0.0);

            // Initialize other vars
            float e = 0.0;
            float R = 0.0;
            float s = 0.0;
            vec3 q = vec3(0.0);
            vec3 p = vec3(0.0);
            
            // Original shader logic starts here
            // Calculate ray direction
            // MODIFIED: Hardcoded zoom and camera position
            vec3 d=vec3(gl_FragCoord.xy/iResolution.y * 0.4 + vec2(-0.2, 0.75), 1.0);
            
            // Init for loop: Set ray origin
            q.y -= 1.0;
            q.z -= 1.0;

            // Raymarch loop
            // MODIFIED: Loop index 'i' cannot be compared with a non-constant uniform.
            // We loop to the slider's max (200.0) and break if i > u_max_steps.
            for(float i = 1.0; i <= 200.0; i++){ 
                if (i > u_max_steps) break; // Manual break using the uniform

                // Accumulate color into 'o'
                o.rgb += u_ambient - hsv(d.z-s/i-d.y+u_hue_offset,u_saturation,min(e*s*e*e,R)/u_brightness);
                
                // Advance ray. 'e' is from previous iteration.
                s=u_step_scale;
                p=q+=d*e*R*u_ray_step_size; 
                
                // Calculate distance from origin
                R=length(p); 

                // Fractal distance estimator logic
                p=vec3(log2(R)-iTime*u_time_scale,exp(R-p.z/R*u_de_param1),atan(p.y+u_de_param2,p.x)*u_de_param3);
                
                // Calculate distance 'e' for the *next* iteration
                e = --p.y; 
                
                // Inner loop
                // MODIFIED: The loop condition (s < u_fractal_limit) must also be constant.
                // We use a dummy loop counter 'k' (max 100 iterations) and break based on 's' and the uniform.
                for(float k = 0.0; k < 100.0; k++) { 
                    if (s >= u_fractal_limit) break; // Real exit condition
                    e+=dot(sin(p.xz*s),sin(p.xx*s+u_fractal_param))/s;
                    s += s; // Manual increment of 's'
                }
            }

            // MODIFIED: Assign to gl_FragColor *once* at the end.
            gl_FragColor = vec4(o.rgb, 1.0);
        }
    </script>

    <!-- Main JavaScript Logic (UNCHANGED per request) -->
    <script>
        function main() {
            const canvas = document.querySelector("#glcanvas");
            const gl = canvas.getContext("webgl");

            if (gl === null) {
                console.error("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }

            // Get shader sources
            const vsSource = document.getElementById("vertex-shader").textContent;
            const fsSource = document.getElementById("fragment-shader").textContent;

            // Initialize shader program
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            if (!shaderProgram) {
                console.error("Shader compilation failed. Cannot create program.");
                return;
            }

            // Collect attribute and uniform locations
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, "a_position"),
                },
                uniformLocations: {
                    // We will get these dynamically
                },
            };

            // --- Uniforms Configuration ---
            // This object holds the current state of all uniforms
            const uniforms = {
                iTime: 0.0,
                sliders: {} // All slider-controlled uniforms go here
            };

            // Get uniform locations
            const uniformNames = [
                "iResolution", "iTime", 
                // MODIFIED: Removed zoom, cam_x, and cam_y
                "u_max_steps",
                "u_ambient", "u_hue_offset", "u_saturation", "u_brightness", "u_step_scale",
                "u_ray_step_size", "u_time_scale", "u_de_param1", "u_de_param2", "u_de_param3",
                "u_fractal_limit", "u_fractal_param"
            ];

            uniformNames.forEach(name => {
                programInfo.uniformLocations[name] = gl.getUniformLocation(shaderProgram, name);
            });

            // --- Slider Creation ---
            const sliderContainer = document.getElementById("slider-container");

            function createSlider(id, name, min, max, step, value) {
                const container = document.createElement("div");
                container.className = "mb-4";

                const label = document.createElement("label");
                label.className = "block text-sm font-medium text-pink-200 mb-1";
                label.htmlFor = id;
                label.textContent = `${name}: ${parseFloat(value).toFixed(2)}`;

                const slider = document.createElement("input");
                slider.type = "range";
                slider.id = id;
                slider.min = min;
                slider.max = max;
                slider.step = step;
                slider.value = value;
                slider.className = "w-full";

                // Set initial uniform value
                uniforms.sliders[id] = parseFloat(value);

                // Update uniform and label on input
                slider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    uniforms.sliders[id] = val;
                    label.textContent = `${name}: ${val.toFixed(2)}`;
                });

                container.appendChild(label);
                container.appendChild(slider);
                sliderContainer.appendChild(container);
            }

            // Create all sliders based on the original shader's hardcoded values
            // MODIFIED: Removed zoom, cam_x, and cam_y sliders
            
            // for( ... i++<99. ... )
            createSlider("u_max_steps", "Max Steps", 1, 200, 1, 99);

            // o.rgb += .028 - hsv(...)
            createSlider("u_ambient", "Ambient Light", 0.0, 0.2, 0.001, 0.028);

            // hsv(d.z-s/i-d.y - .4, .8, min(...)/3.)
            createSlider("u_hue_offset", "Hue Offset", -2.0, 2.0, 0.01, -0.4);
            createSlider("u_saturation", "Saturation", 0.0, 2.0, 0.01, 0.8);
            createSlider("u_brightness", "Brightness", 0.1, 10.0, 0.1, 3.0);
            
            // s=5., p=q+=d*e*R*.1
            createSlider("u_step_scale", "Step Scale (s)", 1.0, 20.0, 0.1, 5.0);
            createSlider("u_ray_step_size", "Ray Step Size", 0.0, 0.5, 0.005, 0.1);

            // p=vec3(log2(R)-t*.5, exp(R-p.z/R*.1), atan(p.y+.03,p.x)*2.)
            createSlider("u_time_scale", "Time Scale", 0.0, 2.0, 0.01, 0.5);
            createSlider("u_de_param1", "DE Param 1 (exp)", 0.0, 1.0, 0.01, 0.1);
            createSlider("u_de_param2", "DE Param 2 (atan y)", 0.0, 0.2, 0.001, 0.03);
            createSlider("u_de_param3", "DE Param 3 (atan mult)", 0.0, 5.0, 0.1, 2.0);

            // for(e=--p.y; s<1e3; s+=s) e+=dot(sin(p.xz*s),sin(p.xx*s+.6))/s;
            createSlider("u_fractal_limit", "Fractal Limit (s)", 100, 5000, 100, 1000);
            createSlider("u_fractal_param", "Fractal Param (sin)", 0.0, 2.0, 0.01, 0.6);
            

            // --- Buffer Setup ---
            const positionBuffer = initBuffers(gl);

            // --- Menu Toggle Logic ---
            const menu = document.getElementById("menu");
            const menuToggle = document.getElementById("menu-toggle");
            menuToggle.addEventListener("click", () => {
                menu.classList.toggle("-translate-x-full");
            });

            // --- Render Loop ---
            function render(now) {
                // Resize canvas to match display size
                if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                }

                // Set uniforms
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(programInfo.program);

                // Set shader uniforms
                setUniforms(gl, programInfo.uniformLocations, uniforms, now);

                // Bind position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    2, // numComponents
                    gl.FLOAT, // type
                    false, // normalize
                    0, // stride
                    0 // offset
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                // Draw the quad
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                // Request next frame
                requestAnimationFrame(render);
            }

            // Start the render loop
            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            // A simple quad that fills the entire screen
            const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return positionBuffer;
        }

        function setUniforms(gl, locations, values, time) {
            gl.uniform2f(locations.iResolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(locations.iTime, time * 0.001); // Convert ms to seconds
            
            // Set all slider-controlled uniforms
            Object.keys(values.sliders).forEach(name => {
                gl.uniform1f(locations[name], values.sliders[name]);
            });
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Start the application
        window.onload = main;
    </script>
</body>
</html>